//Global variables
double couchPos[2] = {0,0};
double homePos[2] = {0,0};
double robotPos[2] = {0,0}
std::string facing = "plusY;"

//Function prototypes
void waitForTouch();
void findCouch();
void menuSelect();
void getDrink();
void moveTo();
void robotTurn();
void robotTurnToFace();
//We need to have at least one return a value. Check line 110

int main()
{
	calibrateAllSensors();
	
	while(true)
	{	//The robot gets placed at the drink stand. Make sure it can see the first drink option in the line.
		
		waitForTouch();
		findCouch(); //(We might be able to change this to make it not have to be in a straight line, but that can come back to this later)
		waitForTouch();
		
		std::string drinkSelection[6] = {"Nothing", "Nothing", "Nothing", "Nothing", "Nothing", "Nothing"}
		menuSelect(drinkSelection);
		
		robotTurn("around");
		moveTo(homePos);
		for (int i = 0; i < 6; i++) //(6?)
		{
			getDrink(drinkSelection[i]); //The robot will go get the drink, pick it up, and put it in a basket (Can be changed to have the for loop include the returnHome() and returnCouch() so that it doesn't need a basket)
		}
		moveTo(couchPos);
		Brain.playSound(tada);
	}
}

void waitForTouch()
{
	while (!touchLED_.pressing()) //rename touchLED_
	{}
	while (touchLED_.presssing()) //rename touchLED_
	{}
}

void findCouch()
{
	const int TURN_AROUND = 180;
	const int NEAR_COUCH = 80;
	
	BrainInertial.setRotation(0,degrees);
	motorLeft.spin(forward, 50, percent);
	motorRght.spin(backward, 50, percent);
	while (BrainIntertial.rotation() < TURN_AROUND)
	{}
	motorLeft.stop(brake);
	motorRight.stop(brake);
	motorLeft.setPosition(0, mm);
	
	motorLeft.spin(forward, 100, percent); //Might have to slow down if it's not precise enough
	motorRght.spin(forward, 100, percent);
	while (distanceSensor.objectDistance(mm) > NEAR_COUCH) //Change the name of the distanceSensor to what it's named in the code
	{}
	motorLeft.stop(brake);
	motorRight.stop(brake);
	couchPos[0] = 0;
	couchPos[1] = motorLeft.position(mm);	//This is so that you're looking at it from a top down view and the drink station is vertically placed from the couch. The x coordinate should be 0 since it's just moving in a straight line.
	
	Brain.Screen.setCursor(1,1);
	Brain.playSound(tada);
	Brain.Screen.print("Hello!\nI am here to serve you.\nPress the touchLED when you want a drink!");
}

void menuSelect(std::string order[6])
{
	bool doneOrdering = false;
	for (int i = 0; i < 6 && !doneOrdering; i++)
	{
		Brain.Screen.clearScreen();
		Brain.Screen.setCursor(1,1);
		Brain.Screen.print("What drink would you like?\n  Fanta\n  Coca Cola\n  Pepsi\n  Sprite\n  DONE");
		Brain.Screen.setCursor(1,1);
		Brain.Screen.print(">");
		while (!Brain.buttonLeft.pressing() && !Brain.buttonRight.pressing())
		{}
		if(Brain.buttonLeft.pressing())
		{
			if (Brain.Screen.row() > 1)
			{
   			  Brain.Screen.setCursor(Brain.Screen.row(), 1);
    		  Brain.Screen.print(" ");      //Should overwrite the > selection arrrow
    		  Brain.Screen.setCursor(Brain.Screen.row() - 1, 1);
    		  Brain.Screen.print(">");
    		}
  		}
  		if (Brain.buttonRight.pressing())
  		{
    		if (Brain.Screen.row() < 5) //Does this count as a magic number??
    		{
    		  Brain.Screen.setCursor(Brain.Screen.row(), 1);
    		  Brain.Screen.print(" ");      //Should clear the > selection arrrow
    		  Brain.Screen.setCursor(Brain.Screen.row() + 1, 1);
    		  Brain.Screen.print(">");
    		}
  		}
  		if (Brain.buttonCheck.pressing())	//We might want to make this a separate function and have it return a string which we can put into the array, because we do need at least one function that returns something. It'll also give us one more function out of six that we need to write.
  		{
  			switch (Brain.Screen.row())
  			{
  		    	case 1:
  		    		order[i] = "Fanta";
  				case 2:
  		    		order[i] = "Coca Cola";
  		    	case 3:
  		    		order[i] = "Pepsi";
  		    	case 4:
  		    		order[i] = "Sprite";
  		    	case 5:
  		    		doneOrdering = true;
  			}
  		}
	}

} //(We could also add an "Other" option that lets you choose a colour in case we put other cans)

void getDrink(std::string drink)	//The robot will go get the drink, pick it up, and put it in a basket
{
	const double CLAW_LENGTH_PLUS_5_MM = 20; //CHANGE ONCE WE MEASURE IT
	std::string searchColour = "Nothing";
	if (drink == "Fanta")
		searchColour = "orange";
	else if (drink == "Coca Cola")
		searchColour = "red";
	else if (drink == "Pepsi")
		searchColour = blue;
	else if (drink == "Sprite")
		searchColour = green;
	
	//The distance sensor and the optical sensor have to be like right on top of the other for this to work, which both have to be like right on top of the claw
	motorLeft.spin(forward,10,percent);
	motorRight.spin(forward,10,percent);
	while (distanceSensor.objectDistance(mm) > CLAW_LENGTH_PLUS_5_MM)	//Change name of distance sensor
	{}
	motorLeft.stop(brake);
	motorRight.stop(brake);
	
	bool drinkFound = false;
	{
		if (Optical.color() != red/*Or any of the other colours of the drinks*/){
		//Adjust the robot's position a little bit to the left/right and try again
		//If we need to, try it again with the light on
		}
		
		if (Optical.color() == searchColour)
		{
			//Grab the drink and put in basket
			drinkFound = true;
			//Move back to (0,0) (home);
		}
		else
		{
			//Move DRINK_SEPARATION_DISTANCE to the right
			//Unless it's out of options. Then return to (0,0)
		}
	}
}

void moveTo(double position[2]) //We might be able to simplify the trajectory of the robot to remove this function
{
	const float STOP_DISTANCE = 15; //Change maybe
	
	while (robotPos[0] != position[0] && robotPos[1] != position[1])
	{
		bool hasMoved = false;
		
		//Orientates the robot to face the correct direction in Y
		if (position[1] > robotPos[1])
			robotTurnToFace("plusY");
		else if (position[1] < robotPos[1])
			robotTurnToFace("minusY");
		//Moves the robot along the Y axis until it can't/doesn't need to anymore
		do
		{
			bool isStuck = false;
			if (distanceSensor.objectDistance(mm) > STOP_DISTANCE)
			{
				motorLeft.spin();
				motorRight.spin();
				hasMoved = true;
			}
			while (distanceSensor.objectDistance(mm) > STOP_DISTANCE && robotPos[1] != position[1])
			{}
			motorLeft.stop(brake);
			motorRight.stop(brake);
			if (robotPos[1] != position[1])	//(If it stopped, but has not yet reached its destination in Y)
			{
				Brain.playSound(alarm2);//HONK GET OUT THE WAY
				wait(7);
			}
			motorLeft.spin();
			motorRight.spin();
			while (distanceSensor.objectDistance(mm) > STOP_DISTANCE && robotPos[1] != position[1])
			{}
			motorLeft.stop(brake);
			motorRight.stop(brake);
			if (robotPos[1] != position[1])	//(If it stopped, but has not yet reached its destination in Y)
				isStuck = true;	//Might add a moveTo(__) function here that brings it back, but we would have to find out where it came from. Otherwise, just do Brain.Program.stop() here I guess.
		} while (robotPos[1] != position[1] && !isStuck);
		
		//Orientates the robot to face the correct direction in X
		if (position[0] > robotPos[0])
			robotTurnToFace("plusX");
		else if (position[0] < robotPos[0])
			robotTurnToFace("minusX");
		//Moves the robot along the X axis until it can't/doesn't need to anymore
		do
		{
			bool isStuck = false;
			if (distanceSensor.objectDistance(mm) > STOP_DISTANCE)
			{
				motorLeft.spin();
				motorRight.spin();
				hasMoved = true;
			}
			while (distanceSensor.objectDistance(mm) > STOP_DISTANCE && robotPos[0] != position[0])
			{}
			motorLeft.stop(brake);
			motorRight.stop(brake);
			if (robotPos[0] != position[0])	//(If it stopped, but has not yet reached its destination in X)
			{
				Brain.playSound(alarm2);//HONK GET OUT THE WAY
				wait(7);
			}
			motorLeft.spin();
			motorRight.spin();
			while (distanceSensor.objectDistance(mm) > STOP_DISTANCE && robotPos[0] != position[0])
			{}
			motorLeft.stop(brake);
			motorRight.stop(brake);
			if (robotPos[0] != position[0])	//(If it stopped, but has not yet reached its destination in X)
				isStuck = true;	//Might add a moveTo(__) function here that brings it back, but we would have to find out where it came from. Otherwise, just do Brain.Program.stop() here I guess.
		} while (robotPos[0] != position[0] && !isStuck);		
				
	/*	Here's basically how the previous mess of code works.
		I understand that this is VERY messy and gross. 
		If you want to change the moveTo function (along with the robotTurn() function and robotTurnToFace() function) or replace it with something else entirely, that would be amazing.
		If not, then I guess we're stuck with this lol. Pray that it works
		We might be able to simplify the trajectory of the robot so that we won't need the moveTo Function and we'll just have a goToCouch() and goHome() function.
			do
			{
				bool stuck = false;
				Try to go along y axis
				If it gets stuck (distance sensor), playsound(alarm2), wait 7 seconds
				Try again
				else, stuck = true;
			} while (y value is not at where it needs to be AND not stuck);
	
			do
			{
				bool stuck = false;
				Try to go along x axis
				If it gets stuck (distance sensor), playsound(alarm2), wait 7 seconds
				Try again
				else, stuck = true;
			} while (x value is not at where it needs to be AND not stuck);
			
			if it truly is unsuccessful, (if it can't move the wheels for either the y axis or the x axis) siren2, wait a second, siren2, wait a second, siren2, wait a second, poweroff sound. Or we could make it try to pathfind its way back
	*/
	}
}

void robotTurn(std::string direction) //Turns the robot either to the left, to the right, or around 180 degrees RELATIVE TO ITSELF
{
	const double TURNING_SPEED = 20, ROTATION_ANGLE = 90;
	
	motorLeft.stop(brake);
	motorRight.stop(brake);
	if (facing == "plusX" || facing == "plusY")
		robotPos[1] = motorLeft.position(mm);
	else if (facing == "minusX" || facing == "minusY")
		robotPos[1] = -motorLeft.position(mm);
	
	BrainIntertial.setRotation(0, degrees);
	if (direction == "right")
	{
		if (facing == plusX)
			facing = minusY;
		else if (facing == minusY)
			facing = minusX;
		else if (facing == minusX)
			facing = plusY;
		else if (facing = plusY)
			facing = plusX;
		motorLeft.spin(forward, TURNING_SPEED, percent);
		motorLeft.spin(reverse, TURNING_SPEED, percent); //Might have to change depending on how the spinning works out
		while (BrainIntertial.rotation(degrees) < ROTATION_ANGLE) //Might have to change the ROTATION_ANGLE and -ROTATION_ANGLE
		{}
	}
	else if (direction == "left")
	{
		if (facing == plusX)
			facing = plusY;
		else if (facing == plusY)
			facing = minusX;
		else if (facing == minusX)
			facing = minusY;
		else if (facing = minusY)
			facing = plusX;
		motorLeft.spin(reverse, TURNING_SPEED, percent);
		motorLeft.spin(forward, TURNING_SPEED, percent);
		while (BrainIntertial.rotation(degrees) > -ROTATION_ANGLE) //Might have to change the ROTATION_ANGLE and -ROTATION_ANGLE
		{}
	}
	else if (direction == "around")
	{
		if (facing == plusX)
			facing = minusX;
		else if (facing == plusY)
			facing = minusY;
		else if (facing == minusX)
			facing = plusX;
		else if (facing = minusY)
			facing = plusY;
		motorLeft.spin(reverse, TURNING_SPEED, percent);
		motorLeft.spin(forward, TURNING_SPEED, percent);
		while (BrainIntertial.rotation(degrees) < 2*ROTATION_ANGLE) //Might have to change the ROTATION_ANGLE and -ROTATION_ANGLE
		{}
	}
	motorLeft.stop(brake);
		motorRight.stop(brake);
	
	if (facing == "plusX")
		motorLeft.setPosition(robotPos[0], mm);
	else if (facing == "plusY")
		motorLeft.setPosition(robotPos[1], mm);
	else if (facing == "minusX")
		motorLeft.setPosition(-robotPos[0], mm);
	else if (facing == "minusY")
		motorLeft.setPosition(-robotPos[1], mm);
}

void robotTurnToFace(std::string direction)
{
	if (direction == "plusX")
	{
		if (facing == "plusY")
			robotTurn("right");
		else if (facing == "minusX")
			robotTurn("around");
		else if (facing == "minusY")
			robotTurn("left");
	}
	else if (direction == "plusY")
	{
		if (facing == "plusX")
			robotTurn("left");
		else if (facing == "minusX")
			robotTurn("right");
		else if (facing == "minusY")
			robutTurn("around");
	}
	else if (direction == "minusX")
	{
		if (facing == "plusX")
			robotTurn("around");
		else if (facing == "plusY")
			robotTurn("left");
		else if (facing == "minusY")
			robotTurn("right");
	}
	else if (direction == "minusY")
	{
		if (facing == "plusX")
			robotTurn("right");
		else if (facing == "plusY")
			robotTurn("around");
		else if (facing == "minusX")
			robotTurn("left");
	}		
}
