#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START IQ MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END IQ MACROS


// Robot configuration code.
inertial BrainInertial = inertial();
motor MotorLeft = motor(PORT3, false);
motor MotorRight = motor(PORT4, true);
optical Optical5 = optical(PORT5);
distance Distance2 = distance(PORT2);
touchled TouchLED12 = touchled(PORT12);


// generating and setting random seed
void initializeRandomSeed(){
  wait(100,msec);
  double xAxis = BrainInertial.acceleration(xaxis) * 1000;
  double yAxis = BrainInertial.acceleration(yaxis) * 1000;
  double zAxis = BrainInertial.acceleration(zaxis) * 1000;
  // Combine these values into a single integer
  int seed = int(
    xAxis + yAxis + zAxis
  );
  // Set the seed
  srand(seed); 
}

// Converts a color to a string
const char* convertColorToString(color col) {
  if (col == colorType::red) return "red";
  else if (col == colorType::green) return "green";
  else if (col == colorType::blue) return "blue";
  else if (col == colorType::white) return "white";
  else if (col == colorType::yellow) return "yellow";
  else if (col == colorType::orange) return "orange";
  else if (col == colorType::purple) return "purple";
  else if (col == colorType::cyan) return "cyan";
  else if (col == colorType::black) return "black";
  else if (col == colorType::transparent) return "transparent";
  else if (col == colorType::red_violet) return "red_violet";
  else if (col == colorType::violet) return "violet";
  else if (col == colorType::blue_violet) return "blue_violet";
  else if (col == colorType::blue_green) return "blue_green";
  else if (col == colorType::yellow_green) return "yellow_green";
  else if (col == colorType::yellow_orange) return "yellow_orange";
  else if (col == colorType::red_orange) return "red_orange";
  else if (col == colorType::none) return "none";
  else return "unknown";
}


// Convert colorType to string
const char* convertColorToString(colorType col) {
  if (col == colorType::red) return "red";
  else if (col == colorType::green) return "green";
  else if (col == colorType::blue) return "blue";
  else if (col == colorType::white) return "white";
  else if (col == colorType::yellow) return "yellow";
  else if (col == colorType::orange) return "orange";
  else if (col == colorType::purple) return "purple";
  else if (col == colorType::cyan) return "cyan";
  else if (col == colorType::black) return "black";
  else if (col == colorType::transparent) return "transparent";
  else if (col == colorType::red_violet) return "red_violet";
  else if (col == colorType::violet) return "violet";
  else if (col == colorType::blue_violet) return "blue_violet";
  else if (col == colorType::blue_green) return "blue_green";
  else if (col == colorType::yellow_green) return "yellow_green";
  else if (col == colorType::yellow_orange) return "yellow_orange";
  else if (col == colorType::red_orange) return "red_orange";
  else if (col == colorType::none) return "none";
  else return "unknown";
}


void vexcodeInit() {

  // Initializing random seed.
  initializeRandomSeed(); 
}

#pragma endregion VEXcode Generated Robot Configuration

//----------------------------------------------------------------------------
//                                                                            
//    Module:       main.cpp                                                  
//    Author:       Adam, Arthur, Isabel, and Arjun                                                  
//    Created:      {date}                                                    
//    Description:  IQ project                                                
//                                                                            
//----------------------------------------------------------------------------

// Include the IQ Library
#include "iq_cpp.h"
#include <string>

// Allows for easier use of the VEX Library
using namespace vex;

void configureAllSensors(){
  BrainInertial.calibrate();
  wait(2,seconds);
  BrainInertial.setHeading(0,degrees);
  BrainInertial.setRotation(0,degrees);
  MotorLeft.setPosition(0,turns);
  MotorRight.setPosition(0,turns);
  Brain.Screen.clearScreen();
  Brain.Screen.setFont(mono15);
  Optical5.setLight(ledState::on);
}

//Function prototypes
void waitForTouch();
void findCouch(int couchPos[2]);
void menuSelect(std::string order[]);
void getSnack(std::string snack);
void moveTo(double position[2], std::string& facing);
void robotTurn(std::string direction, std::string& facing);
void robotTurnToFace(std::string direction, std::string& facing);
//We need to have at least one return a value. Check line 110

const int X = 0, Y = 1;
const double WHEEL_CIRC = 200;

int main()
{
  // Initializing Robot Configuration. DO NOT REMOVE!
  vexcodeInit();
  // Begin project code
	configureAllSensors();

  double couchPos[2] = {0,0};
  double homePos[2] = {0,0};
  double robotPos[2] = {0,0};
  std::string facing = "plusY;";
  const int NUM_ORDERS = 2;
	bool endProgram = false;

	while(!endProgram)
	{	//The robot gets placed at the snack stand. Make sure it can see the first snack option in the line.
		
		waitForTouch();
		findCouch(couchPos); //(We might be able to change this to make it not have to be in a straight line, but that can come back to this later)
		waitForTouch();
		
		std::string snackSelection[NUM_ORDERS] = {""};
    for (int i = 0; i < NUM_ORDERS; i++)
      snackSelection[i] = "Nothing";
		menuSelect(snackSelection);
		
		robotTurn("around");
		moveTo(homePos);
		for (int i = 0; i < NUM_ORDERS; i++)
		{
			getSnack(snackSelection[i]); //The robot will go get the snack, pick it up, and put it in a basket (Can be changed to have the for loop include the returnHome() and returnCouch() so that it doesn't need a basket)
		}
		moveTo(couchPos);
		Brain.playSound(tada);
	}
}

void waitForTouch()
{
	while (!TouchLED12.pressing())
	{}
	while (TouchLED12.pressing())
	{}
}

void findCouch(int couchPos[2])
{
	const int TURN_AROUND = 180;
	const int NEAR_COUCH = 80;
	
	BrainInertial.setRotation(0,degrees);
	MotorLeft.spin(forward, 50, percent);
	motorRght.spin(reverse, 50, percent);
	while (BrainInertial.rotation() < TURN_AROUND)
	{}
	MotorLeft.stop(brake);
	MotorRight.stop(brake);
	MotorLeft.setPosition(0, mm * WHEEL_CIRC);
	
	MotorLeft.spin(forward, 100, percent); //Might have to slow down if it's not precise enough
	motorRght.spin(forward, 100, percent);
	while (Distance1.objectDistance(mm) > NEAR_COUCH) //Change the name of the Distance1 to what it's named in the code
	{}
	MotorLeft.stop(brake);
	MotorRight.stop(brake);
	couchPos[0] = 0;
	couchPos[1] = MotorLeft.position(mm);	//This is so that you're looking at it from a top down view and the snack station is vertically placed from the couch. The x coordinate should be 0 since it's just moving in a straight line.
	
	Brain.Screen.setCursor(1,1);
	Brain.playSound(tada);
	Brain.Screen.print("Hello!\nI am here to serve you.\nPress the touchLED when you want a snack!");
}

void menuSelect(std::string order[numOrders])
{
	bool doneOrdering = false;
	for (int i = 0; i < numOrders && !doneOrdering; i++)
	{
		Brain.Screen.clearScreen();
		Brain.Screen.setCursor(1,1);
		Brain.Screen.print("What snack would you like?\n  Fanta\n  Coca Cola\n  Pepsi\n  Sprite\n  DONE");
		Brain.Screen.setCursor(1,1);
		Brain.Screen.print(">");
		while (!Brain.buttonLeft.pressing() && !Brain.buttonRight.pressing())
		{}
		if(Brain.buttonLeft.pressing())
		{
			if (Brain.Screen.row() > 1)
			{
   			  Brain.Screen.setCursor(Brain.Screen.row(), 1);
    		  Brain.Screen.print(" ");      //Should overwrite the > selection arrrow
    		  Brain.Screen.setCursor(Brain.Screen.row() - 1, 1);
    		  Brain.Screen.print(">");
    		}
  		}
  		if (Brain.buttonRight.pressing())
  		{
    		if (Brain.Screen.row() < 5) //Does this count as a magic number??
    		{
    		  Brain.Screen.setCursor(Brain.Screen.row(), 1);
    		  Brain.Screen.print(" ");      //Should clear the > selection arrrow
    		  Brain.Screen.setCursor(Brain.Screen.row() + 1, 1);
    		  Brain.Screen.print(">");
    		}
  		}
  		if (Brain.buttonCheck.pressing())	//We might want to make this a separate function and have it return a string which we can put into the array, because we do need at least one function that returns something. It'll also give us one more function out of six that we need to write.
  		{
  			switch (Brain.Screen.row())
  			{
  		    	case 1:
  		    		order[i] = "Fanta";
  				case 2:
  		    		order[i] = "Coca Cola";
  		    	case 3:
  		    		order[i] = "Pepsi";
  		    	case 4:
  		    		order[i] = "Sprite";
  		    	case 5:
  		    		doneOrdering = true;
  			}
  		}
	}

} //(We could also add an "Other" option that lets you choose a colour in case we put other cans)

void getSnack(std::string snack)	//The robot will go get the snack, pick it up, and put it in a basket
{
	const double CLAW_LENGTH_PLUS_5_MM = 20; //CHANGE ONCE WE MEASURE IT
	std::string searchColour = "Nothing";
	if (snack == "Fanta")
		searchColour = "orange";
	else if (snack == "Coca Cola")
		searchColour = "red";
	else if (snack == "Pepsi")
		searchColour = blue;
	else if (snack == "Sprite")
		searchColour = green;
	
	//The distance sensor and the Optical5 sensor have to be like right on top of the other for this to work, which both have to be like right on top of the claw
	MotorLeft.spin(forward,10,percent);
	MotorRight.spin(forward,10,percent);
	while (Distance1.objectDistance(mm) > CLAW_LENGTH_PLUS_5_MM)	//Change name of distance sensor
	{}
	MotorLeft.stop(brake);
	MotorRight.stop(brake);
	
	bool snackFound = false;
	{
		if (Optical5.color() != red/*Or any of the other colours of the snacks*/){
		//Adjust the robot's position a little bit to the left/right and try again
		//If we need to, try it again with the light on
		}
		
		if (Optical5.color() == searchColour)
		{
			//Grab the snack and put in basket
			snackFound = true;
			//Move back to (0,0) (home);
		}
		else
		{
			//Move SNACK_SEPARATION_DISTANCE to the right
			//Unless it's out of options. Then return to (0,0)
		}
	}
}

void moveTo(double position[2], std::string& facing) //We might be able to simplify the trajectory of the robot to remove this function
{
}

// Take out the object avoidance thing 
// We might want to change how the object detection works. Maybe in the future it can return to the position when the function was called so that the robot can easily return to either the snack hub or couch.
// If that's too complicated and we can't do Brain.Program.stop(), then maybe just have the honking thing.

//The robot will stop, honk, and wait a few seconds. If the object is gone, the function ends. If not, it tries to go around it from the right.
//If it gets stuck along the way, it sounds an alarm so that someone can come and get it. (I don't think we're allowed to Brain.Program.stop() unless it's at the end of the program unfortunately)
void avoidObstacle()
{
	const int SPEED = 50; // Put in global probably
	const float STOP_DISTANCE = 15; //Change maybe
	const float AVOID_DISTANCE = 30;
	
	MotorLeft.stop(brake);
	MotorRight.stop(brake);
	
	Brain.playSound(alarm2); //HONK GET OUT THE WAY
	wait(7, seconds)
	
	if (Distance1.objectDistance(mm) > STOP_DISTANCE)
	{
		float lastEncoderVal = 0;
		bool isStuck = false;
		std::string direction = "right";
		
		for (int i = 0; i < 4; i++) //Should 4 be a const?
		{
			if (i == 0 || i == 3)
				robotTurn("right");
			else
				robotTurn("left");
			if (Distance1.objectDistance(mm) > STOP_DISTANCE)
					isStuck = true;
			if (!isStuck)
			{
				lastEncoderVal = MotorLeft.position();
				MotorLeft.spin(SPEED);
				MotorRight.spin(SPEED);
				while (MotorLeft.position(mm) - lastEncoderVal < AVOID_DISTANCE)
				{}
				MotorLeft.stop(brake);
				MotorRight.stop(brake);
			}
			else 
			{
				for (int i = 0; i < 5; i++)
				{
					Brain.playSound(siren2);
					wait(3, seconds);
				}
			}
		}
	}
}



void robotTurn(std::string direction, std::string& facing) //Turns the robot either to the left, to the right, or around 180 degrees RELATIVE TO ITSELF
{
	const double TURNING_SPEED = 20, ROTATION_ANGLE = 90;
	
	MotorLeft.stop(brake);
	MotorRight.stop(brake);
	if (facing == "plusX" || facing == "plusY")
		robotPos[1] = MotorLeft.position(mm);
	else if (facing == "minusX" || facing == "minusY")
		robotPos[1] = -MotorLeft.position(mm);
	
	BrainIntertial.setRotation(0, degrees);
	if (direction == "right")
	{
		if (facing == plusX)
			facing = minusY;
		else if (facing == minusY)
			facing = minusX;
		else if (facing == minusX)
			facing = plusY;
		else if (facing = plusY)
			facing = plusX;
		MotorLeft.spin(forward, TURNING_SPEED, percent);
		MotorLeft.spin(reverse, TURNING_SPEED, percent); //Might have to change depending on how the spinning works out
		while (BrainIntertial.rotation(degrees) < ROTATION_ANGLE) //Might have to change the ROTATION_ANGLE and -ROTATION_ANGLE
		{}
	}
	else if (direction == "left")
	{
		if (facing == plusX)
			facing = plusY;
		else if (facing == plusY)
			facing = minusX;
		else if (facing == minusX)
			facing = minusY;
		else if (facing = minusY)
			facing = plusX;
		MotorLeft.spin(reverse, TURNING_SPEED, percent);
		MotorLeft.spin(forward, TURNING_SPEED, percent);
		while (BrainIntertial.rotation(degrees) > -ROTATION_ANGLE) //Might have to change the ROTATION_ANGLE and -ROTATION_ANGLE
		{}
	}
	else if (direction == "around")
	{
		if (facing == plusX)
			facing = minusX;
		else if (facing == plusY)
			facing = minusY;
		else if (facing == minusX)
			facing = plusX;
		else if (facing = minusY)
			facing = plusY;
		MotorLeft.spin(reverse, TURNING_SPEED, percent);
		MotorLeft.spin(forward, TURNING_SPEED, percent);
		while (BrainIntertial.rotation(degrees) < 2*ROTATION_ANGLE) //Might have to change the ROTATION_ANGLE and -ROTATION_ANGLE
		{}
	}
	MotorLeft.stop(brake);
		MotorRight.stop(brake);
	
	if (facing == "plusX")
		MotorLeft.setPosition(robotPos[0], mm);
	else if (facing == "plusY")
		MotorLeft.setPosition(robotPos[1], mm);
	else if (facing == "minusX")
		MotorLeft.setPosition(-robotPos[0], mm);
	else if (facing == "minusY")
		MotorLeft.setPosition(-robotPos[1], mm);
}

void robotTurnToFace(std::string direction, std::string& facing) //this needs a parameter
{
	if (direction == "plusX")
	{
		if (facing == "plusY")
			robotTurn("right", facing);
		else if (facing == "minusX")
			robotTurn("around", facing);
		else if (facing == "minusY")
			robotTurn("left", facing);
	}
	else if (direction == "plusY")
	{
		if (facing == "plusX")
			robotTurn("left", facing);
		else if (facing == "minusX")
			robotTurn("right", facing);
		else if (facing == "minusY")
			robutTurn("around", facing);
	}
	else if (direction == "minusX")
	{
		if (facing == "plusX")
			robotTurn("around", facing);
		else if (facing == "plusY")
			robotTurn("left", facing);
		else if (facing == "minusY")
			robotTurn("right", facing);
	}
	else if (direction == "minusY")
	{
		if (facing == "plusX")
			robotTurn("right", facing);
		else if (facing == "plusY")
			robotTurn("around", facing);
		else if (facing == "minusX")
			robotTurn("left", facing);
	}		
}
