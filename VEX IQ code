//Global variables
double couchPos[2] = {0,0};
double homePos[2] = {0,0};
double robotPos[2] = {0,0}
std::string facing = "plusY;"
//double robotPos[2] = {0,0}; May or may not need depending on how we make the coordinate system work

//Function prototypes
void waitForTouch();
void findCouch();
void menuSelect();
void returnHome();
void getDrink();
void returnToCouch();
//We need to have at least one return a value. Check line 110

int main()
{
	calibrateAllSensors();
	
	while(true)
	{	//The robot gets placed at the drink stand. Make sure it can see the first drink option in the line.
		
		waitForTouch();
		findCouch(); //(We might be able to change this to make it not have to be in a straight line, but that can come back to this later)
		waitForTouch();
		
		std::string drinkSelection[6] = {"Nothing", "Nothing", "Nothing", "Nothing", "Nothing", "Nothing"}
		menuSelect(drinkSelection);
		
		//Turn around (Didn't program because it'll be done differently depending on how we do the coordinate system)
		//returnHome(); (Will include object-detection code. Didn't program yet because it'll be done differently depending on how we do the coordinate system)
		for (int i = 0; i < 6; i++) //(6?)
		{
			getDrink(drinkSelection[i]); //The robot will go get the drink, pick it up, and put it in a basket (Can be changed to have the for loop include the returnHome() and returnCouch() so that it doesn't need a basket)
		}
		returnToCouch();
		Brain.playSound(tada);
	}
}

void waitForTouch()
{
	while (!touchLED_.pressing()) //rename touchLED_
	{}
	while (touchLED_.presssing()) //rename touchLED_
	{}
}

void findCouch()
{
	const int TURN_AROUND = 180;
	const int NEAR_COUCH = 80;
	
	BrainInertial.setRotation(0,degrees);
	motorLeft.spin(forward, 50, percent);
	motorRght.spin(backward, 50, percent);
	while (BrainIntertial.rotation() < TURN_AROUND)
	{}
	motorLeft.stop(brake);
	motorRight.stop(brake);
	motorLeft.setPosition(0, mm);
	//motorRight.setPosition(0, mm); May or may not be necessary depending on how we do the wheels
	
	motorLeft.spin(forward, 100, percent); //Might have to slow down if it's not precise enough
	motorRght.spin(forward, 100, percent);
	while (distanceSensor.objectDistance(mm) > NEAR_COUCH) //Change the name of the distanceSensor to what it's named in the code
	{}
	motorLeft.stop(brake);
	motorRight.stop(brake);
	couchPos[0] = 0;
	couchPos[1] = motorLeft.position(mm);	//This is so that you're looking at it from a top down view and the drink station is vertically placed from the couch. The x coordinate should be 0 since it's just moving in a straight line.
	
	Brain.Screen.setCursor(1,1);
	Brain.playSound(tada);
	Brain.Screen.print("Hello!\nI am here to serve you.\nPress the touchLED when you want a drink!");
}

void menuSelect(std::string order[6])
{
	bool doneOrdering = false;
	for (int i = 0; i < 6 && !doneOrdering; i++)
	{
		Brain.Screen.clearScreen();
		Brain.Screen.setCursor(1,1);
		Brain.Screen.print("What drink would you like?\n  Fanta\n  Coca Cola\n  Pepsi\n  Sprite\n  DONE");
		Brain.Screen.setCursor(1,1);
		Brain.Screen.print(">");
		while (!Brain.buttonLeft.pressing() && !Brain.buttonRight.pressing())
		{}
		if(Brain.buttonLeft.pressing())
		{
			if (Brain.Screen.row() > 1)
			{
   			  Brain.Screen.setCursor(Brain.Screen.row(), 1);
    		  Brain.Screen.print(" ");      //Should overwrite the > selection arrrow
    		  Brain.Screen.setCursor(Brain.Screen.row() - 1, 1);
    		  Brain.Screen.print(">");
    		}
  		}
  		if (Brain.buttonRight.pressing())
  		{
    		if (Brain.Screen.row() < 5) //Does this count as a magic number??
    		{
    		  Brain.Screen.setCursor(Brain.Screen.row(), 1);
    		  Brain.Screen.print(" ");      //Should clear the > selection arrrow
    		  Brain.Screen.setCursor(Brain.Screen.row() + 1, 1);
    		  Brain.Screen.print(">");
    		}
  		}
  		if (Brain.buttonCheck.pressing())	//We might want to make this a separate function and have it return a string which we can put into the array, because we do need at least one function that returns something. It'll also give us one more function out of six that we need to write.
  		{
  			switch (Brain.Screen.row())
  			{
  		    	case 1:
  		    		order[i] = "Fanta";
  				case 2:
  		    		order[i] = "Coca Cola";
  		    	case 3:
  		    		order[i] = "Pepsi";
  		    	case 4:
  		    		order[i] = "Sprite";
  		    	case 5:
  		    		doneOrdering = true;
  			}
  		}
	}

} //(We could also add an "Other" option that lets you choose a colour in case we put other cans)

void returnHome()
{
	
}

void getDrink(std::string drink)	//The robot will go get the drink, pick it up, and put it in a basket
{
	const double CLAW_LENGTH_PLUS_5_MM = 20; //CHANGE ONCE WE MEASURE IT
	std::string searchColour = "Nothing";
	if (drink == "Fanta")
		searchColour = "orange";
	else if (drink == "Coca Cola")
		searchColour = "red";
	else if (drink == "Pepsi")
		searchColour = blue;
	else if (drink == "Sprite")
		searchColour = green;
	
	//The distance sensor and the optical sensor have to be like right on top of the other for this to work, which both have to be like right on top of the claw
	motorLeft.spin(forward,10,percent);
	motorRight.spin(forward,10,percent);
	while (distanceSensor.objectDistance(mm) > CLAW_LENGTH_PLUS_5_MM)	//Change name of distance sensor
	{}
	motorLeft.stop(brake);
	motorRight.stop(brake);
	
	bool drinkFound = false;
	{
		if (Optical.color() != red/*Or any of the other colours of the drinks*/){
		//Adjust the robot's position a little bit to the left/right and try again
		//If we need to, try it again with the light on
		}
		
		if (Optical.color() == searchColour)
		{
			//Grab the drink and put in basket
			drinkFound = true;
			//Move back to (0,0) (home);
		}
		else
		{
			//Move DRINK_SEPARATION_DISTANCE to the right
			//Unless it's out of options. Then return to (0,0)
		}
	}
}

void returnToCouch()
{
	
}

void moveTo(double position[2])
{
	if (position[0] < robotPos[0])
		robotTurn(______);
	while (robotPos[0] != position[0] && robotPos[1] != position[1])
	{
		do
		{
			bool isStuck = false;
		} while ();
	}
	//while (not at position)
	//{
			/*
			//do
			{
				//bool stuck = false;
				//Try to go along y axis
				//If it gets stuck (distance sensor), playsound(alarm2), wait 7 seconds
				//Try again. If stuck, strafe to the right a bit, then try to go forward again.
				//If stuck, strafe a bit to the left, then tray to go forward again.
			} while (y value is not at where it needs to be AND not stuck);
	
			//do
			{
				//bool stuck = false;
				//Try to go along x axis
				//If it gets stuck (distance sensor), playsound(alarm2), wait 7 seconds
				//Try again. If stuck, strafe to the right a bit, then try to go forward again.
				//If stuck, strafe a bit to the left, then tray to go forward again.
				//else, stuck = true;
			} while (x value is not at where it needs to be AND not stuck);
			*/
			
			//if it truly is unsuccessful, (if it can't move the wheels for either the y axis or the x axis) siren2, wait a second, siren2, wait a second, siren2, wait a second, poweroff sound. Or we could make it try to pathfind its way back
	//}	
	
}

void robotTurn(std::string direction) //Turns the robot either to the left or to the right RELATIVE TO ITSELF
{
	const double TURNING_SPEED = 20, ROTATION_ANGLE = 90;
	
	motorLeft.stop(brake);
	motorRight.stop(brake);
	if (facing == "plusX" || facing == "plusY")
		robotPos[1] = motorLeft.position(mm);
	else if (facing == "minusX" || facing == "minusY")
		robotPos[1] = -motorLeft.position(mm);
	
	BrainIntertial.setRotation(0, degrees);
	if (direction == "right")
	{
		if (facing == plusX)
			facing = minusY;
		else if (facing == minusY)
			facing = minusX;
		else if (facing == minusX)
			facing = plusY;
		else if (facing = plusY)
			facing = plusX;
		motorLeft.spin(forward, TURNING_SPEED, percent);
		motorLeft.spin(reverse, TURNING_SPEED, percent); //Might have to change depending on how the spinning works out
		while (BrainIntertial.rotation(degrees) < ROTATION_ANGLE) //Might have to change the ROTATION_ANGLE and -ROTATION_ANGLE
		{}
	}
	else if (direction == "left")
	{
		if (facing == plusX)
			facing = plusY;
		else if (facing == plusY)
			facing = minusX;
		else if (facing == minusX)
			facing = minusY;
		else if (facing = minusY)
			facing = plusX;
		motorLeft.spin(reverse, TURNING_SPEED, percent);
		motorLeft.spin(forward, TURNING_SPEED, percent);
		while (BrainIntertial.rotation(degrees) > -ROTATION_ANGLE) //Might have to change the ROTATION_ANGLE and -ROTATION_ANGLE
		{}
	}
	motorLeft.stop(brake);
		motorRight.stop(brake);
	
	if (facing == "plusX")
		motorLeft.setPosition(robotPos[0], mm);
	else if (facing == "plusY")
		motorLeft.setPosition(robotPos[1], mm);
	else if (facing == "minusX")
		motorLeft.setPosition(-robotPos[0], mm);
	else if (facing == "minusY")
		motorLeft.setPosition(-robotPos[1], mm);
}
