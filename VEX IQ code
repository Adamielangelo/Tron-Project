#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>

#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;

// START IQ MACROS
#define waitUntil(condition) \
    do                       \
    {                        \
        wait(5, msec);       \
    } while (!(condition))

#define repeat(iterations) \
    for (int iterator = 0; iterator < iterations; iterator++)
// END IQ MACROS

// Robot configuration code.
inertial BrainInertial = inertial();
motor MotorLeft = motor(PORT3, false);
motor MotorRight = motor(PORT4, true);
motor MotorGrab = motor(PORT5, false);
motor MotorVert = motor(PORT1, true);
optical Optical6 = optical(PORT6);
distance Distance2 = distance(PORT2);
touchled TouchLED12 = touchled(PORT12);

// generating and setting random seed
void initializeRandomSeed()
{
    wait(100, msec);
    double xAxis = BrainInertial.acceleration(xaxis) * 1000;
    double yAxis = BrainInertial.acceleration(yaxis) * 1000;
    double zAxis = BrainInertial.acceleration(zaxis) * 1000;
    // Combine these values into a single integer
    int seed = int(
        xAxis + yAxis + zAxis);
    // Set the seed
    srand(seed);
}

// Converts a color to a string
const char *convertColorToString(color col)
{
    if (col == colorType::red)
        return "red";
    else if (col == colorType::green)
        return "green";
    else if (col == colorType::blue)
        return "blue";
    else if (col == colorType::white)
        return "white";
    else if (col == colorType::yellow)
        return "yellow";
    else if (col == colorType::orange)
        return "orange";
    else if (col == colorType::purple)
        return "purple";
    else if (col == colorType::cyan)
        return "cyan";
    else if (col == colorType::black)
        return "black";
    else if (col == colorType::transparent)
        return "transparent";
    else if (col == colorType::red_violet)
        return "red_violet";
    else if (col == colorType::violet)
        return "violet";
    else if (col == colorType::blue_violet)
        return "blue_violet";
    else if (col == colorType::blue_green)
        return "blue_green";
    else if (col == colorType::yellow_green)
        return "yellow_green";
    else if (col == colorType::yellow_orange)
        return "yellow_orange";
    else if (col == colorType::red_orange)
        return "red_orange";
    else if (col == colorType::none)
        return "none";
    else
        return "unknown";
}

// Convert colorType to string
const char *convertColorToString(colorType col)
{
    if (col == colorType::red)
        return "red";
    else if (col == colorType::green)
        return "green";
    else if (col == colorType::blue)
        return "blue";
    else if (col == colorType::white)
        return "white";
    else if (col == colorType::yellow)
        return "yellow";
    else if (col == colorType::orange)
        return "orange";
    else if (col == colorType::purple)
        return "purple";
    else if (col == colorType::cyan)
        return "cyan";
    else if (col == colorType::black)
        return "black";
    else if (col == colorType::transparent)
        return "transparent";
    else if (col == colorType::red_violet)
        return "red_violet";
    else if (col == colorType::violet)
        return "violet";
    else if (col == colorType::blue_violet)
        return "blue_violet";
    else if (col == colorType::blue_green)
        return "blue_green";
    else if (col == colorType::yellow_green)
        return "yellow_green";
    else if (col == colorType::yellow_orange)
        return "yellow_orange";
    else if (col == colorType::red_orange)
        return "red_orange";
    else if (col == colorType::none)
        return "none";
    else
        return "unknown";
}

void vexcodeInit()
{

    // Initializing random seed.
    initializeRandomSeed();
}

#pragma endregion VEXcode Generated Robot Configuration

//----------------------------------------------------------------------------
//
//    Module:       main.cpp
//    Authors:       Adam, Arthur, Isabel, and Arjun
//    Created:      {date}
//    Description:  IQ project
//
//----------------------------------------------------------------------------

// Include the IQ Library
#include "iq_cpp.h"
#include <string>
#include <cmath>

// Allows for easier use of the VEX Library
using namespace vex;

void configureAllSensors()
{
    BrainInertial.calibrate();
    wait(2, seconds);
    BrainInertial.setHeading(0, degrees);
    BrainInertial.setRotation(0, degrees);
    MotorLeft.setPosition(0, turns);
    MotorRight.setPosition(0, turns);
    Brain.Screen.clearScreen();
    Brain.Screen.setFont(mono15);
    Optical6.setLight(ledState::on);
}

// Function prototypes
void waitForTouch();
void findCouch(double &couchPos, double &robotPos);
void menuSelect(std::string order[], bool &endProgram);
bool confirm(const std::string chipString);
bool moveTo(double targetPos, double &robotPos, double couchPos);
bool obstacleAlarm(const double SAFE_DISTANCE);
void updateRobotPos(double &robotPos);
void robotTurn(std::string direction);
void getSnack(std::string order[2]);
void nextChip(std::string colour);
void dropBasket();

const double WHEEL_CIRC = 200;
const double ROBOT_LENGTH = 250; 
const double FINAL_TOLERANCE = 0.05;
const double SAFE_DISTANCE = 120;
const int SPEED = 40;

const int NUM_ORDERS = 2;
const int GRAB_SPEED = 10;
const double CHIP_DISTANCE = 220;
const double VERT_MOTOR_DEGREES = 2000;
const double CLAW_MOTOR_DEGREES = 100;
const double HOLD_CHIPS = 5;
const double SUN_CHIPS_START_DEGREES = 15, SUN_CHIPS_END_DEGREES = 45, QUEST_CHIPS_START_DEGREES = 50, QUEST_CHIPS_END_DEGREES = 120, LAYS_START_DEGREES = 210, LAYS_END_DEGREES = 320;

int main()
{
    // configuring vex
    vexcodeInit();
    configureAllSensors();
    wait(1, seconds);

    // initialize variables
    double couchPos = 0;
    double snackPos = 0;
    double robotPos = 0;
    std::string snackSelection[NUM_ORDERS] = {""};
    bool endProgram = false;

    snackSelection[0] = "Sun Chips";
    snackSelection[1] = "Lays";
    getSnack(snackSelection);
    /*waitForTouch();
    findCouch(couchPos, robotPos); // give couchPos a positive value
    while (!endProgram)
    {
      waitForTouch();
      menuSelect(snackSelection, endProgram);
      moveTo(snackPos, robotPos, couchPos);
      getSnack(snackSelection);
      moveTo(couchPos, robotPos, couchPos);
      Brain.playSound(tada);
      MotorGrab.stop();
      wait(20, seconds);
      robotTurn("around");
    }*/

    Brain.programStop();
}

void waitForTouch()
{
    while (!TouchLED12.pressing())
    {
    }
    while (TouchLED12.pressing())
    {
    }
}

void findCouch(double &couchPos, double &robotPos)
{
    const int NEAR_COUCH = 240; // Distance between the distance sensor and the couch

    MotorLeft.spin(reverse, SPEED, percent);
    MotorRight.spin(reverse, SPEED, percent);
    while (MotorLeft.position(turns) * WHEEL_CIRC > -ROBOT_LENGTH)
    {
    }
    MotorLeft.stop(brake);
    MotorRight.stop(brake);

    robotTurn("around");
    MotorLeft.setPosition(0, turns);

    MotorLeft.spin(forward, SPEED, percent);
    MotorRight.spin(forward, SPEED, percent);
    while (Distance2.objectDistance(mm) > NEAR_COUCH)
    {
    }
    MotorLeft.stop(brake);
    MotorRight.stop(brake);
    couchPos = MotorLeft.position(turns);
    robotPos = couchPos;

    robotTurn("around");

    Brain.Screen.setCursor(1, 1);
    
    Brain.Screen.print("Hello! I am here ");
    Brain.Screen.newLine();
    Brain.Screen.print("to serve you. Press the");
    Brain.Screen.newLine();
    Brain.Screen.print("touchLED when you");
    Brain.Screen.newLine();
    Brain.Screen.print("want a snack!");
    Brain.playSound(tada);
}

void menuSelect(std::string order[NUM_ORDERS], bool &endProgram)
{
    const int NUM_OPTIONS = 6;
    bool doneOrdering = false;
    bool snackSelected = false;

    for (int i = 0; (i < NUM_ORDERS) && (!doneOrdering) && (!endProgram); i++)
    {
        Brain.Screen.clearScreen();
        Brain.Screen.setCursor(1, 1);
        Brain.Screen.print("  What snack?");
        Brain.Screen.newLine();
        Brain.Screen.print("  Sun Chips");
        Brain.Screen.newLine();
        Brain.Screen.print("  Quest Chips");
        Brain.Screen.newLine();
        Brain.Screen.print("  Lays");
        Brain.Screen.newLine();
        Brain.Screen.print("  Done");
        Brain.Screen.newLine();
        Brain.Screen.print("  End Program");
        Brain.Screen.setCursor(2, 1);
        Brain.Screen.print(">");

        snackSelected = false;
        while (!snackSelected)
        {
            std::string buttonPressed = "";
            while (!Brain.buttonLeft.pressing() && !Brain.buttonRight.pressing() && !Brain.buttonCheck.pressing())
            {
            }
            if (Brain.buttonLeft.pressing())
                buttonPressed = "left";
            if (Brain.buttonRight.pressing())
                buttonPressed = "right";
            if (Brain.buttonCheck.pressing())
                buttonPressed = "check";
            while (Brain.buttonLeft.pressing() || Brain.buttonRight.pressing() || Brain.buttonCheck.pressing())
            {
            }
            if (buttonPressed == "left")
            {
                if (Brain.Screen.row() > 2)
                {
                    Brain.Screen.setCursor(Brain.Screen.row(), 1);
                    Brain.Screen.print(" "); // Overwrites the > selection arrrow
                    Brain.Screen.setCursor(Brain.Screen.row() - 1, 1);
                    Brain.Screen.print(">");
                }
            }
            if (buttonPressed == "right")
            {
                if (Brain.Screen.row() < NUM_OPTIONS)
                {
                    Brain.Screen.setCursor(Brain.Screen.row(), 1);
                    Brain.Screen.print(" "); // Clears the > selection arrrow
                    Brain.Screen.setCursor(Brain.Screen.row() + 1, 1);
                    Brain.Screen.print(">");
                }
            }
            if (buttonPressed == "check")
            {
                if (Brain.Screen.row() == 2)
                    order[i] = "Sun Chips";
                else if (Brain.Screen.row() == 3)
                    order[i] = "Quest Chips";
                else if (Brain.Screen.row() == 4)
                    order[i] = "Lays";
                else if (Brain.Screen.row() == 5)
                {
                    order[i] = "Nothing";
                    doneOrdering = true;
                }
                else if (Brain.Screen.row() == 6)
                    endProgram = true;
                snackSelected = true;

                if (!endProgram)
                {
                    if (!confirm(order[i]))
                        i--;
                }
            }
        }
    }
}

bool confirm(const std::string chipString)
{
    Brain.Screen.clearScreen();
    Brain.Screen.setCursor(1, 1);
    Brain.Screen.print("Selected: %s", chipString.c_str());
    Brain.Screen.newLine();
    Brain.Screen.newLine();
    Brain.Screen.print("Right to confirm");
    Brain.Screen.newLine();
    Brain.Screen.print("Left to cancel"); // Might change menu
    // Lines above set the screen and then it displays a confirmation message and returns the users choice back to them so they can see their choice and decide if they want something else or if that's what they meant to select.
    while (true) // loop waits until user presses check or x
    {
        if (Brain.buttonRight.pressing()) // checks if check button is pressed
        {
            while (Brain.buttonRight.pressing()) // waits until the button is released
            {
            }
            return true; // returns true if check is pressed
        }
        else if (Brain.buttonLeft.pressing())
        {
            while (Brain.buttonLeft.pressing())
            {
            }
            return false;
        }
    }
}

void getSnack(std::string order[NUM_ORDERS])
{
  const double DISTANCE_FROM_BACK_OF_RACK = 25;
  const double CHIP_DISTANCE_CORRECTION_FACTOR = 40;

  for (int i = 0; i < 2; i++)
  {
    //reading the chip bag orders in array
    std::string colour = order[i];

    //if there is only one order, ensures it only fulfils one order
    if (colour != "Nothing")
    {
      MotorVert.spin(forward, SPEED, percent);
      while(MotorVert.position(degrees) < VERT_MOTOR_DEGREES)
      {}
      MotorVert.stop(brake);
     
      MotorGrab.spin(forward, GRAB_SPEED, percent);
      while (MotorGrab.position(degrees) < CLAW_MOTOR_DEGREES)
      {}
      MotorGrab.stop();




      //for 3 chip types CHANGE WHEN WE GET OPTIONS, Also make this a const int variable NOTENOTE
      for (int p = 0; p < 3; p++)
      {
        Brain.playSound(tada);
        Brain.Screen.clearScreen();
        Brain.Screen.setCursor(1,1);
        Brain.Screen.print("i:%d p:%d", i, p);
        //drive fwd until close enough to chip bag
        MotorLeft.spin(forward, SPEED, percent);
        MotorRight.spin(forward, SPEED, percent);
        while(Distance2.objectDistance(mm) > DISTANCE_FROM_BACK_OF_RACK)
        {}
        MotorLeft.stop();
        MotorRight.stop();

        wait(1, seconds);
        if (((colour == "Sun Chips") && (Optical6.hue() > SUN_CHIPS_START_DEGREES && Optical6.hue() < SUN_CHIPS_END_DEGREES))
          || ((colour == "Quest Chips") &&  (Optical6.hue() > QUEST_CHIPS_START_DEGREES && Optical6.hue() < QUEST_CHIPS_END_DEGREES))
          || ((colour == "Lays") && (Optical6.hue() > LAYS_START_DEGREES && Optical6.hue() < LAYS_END_DEGREES)))
        {
          MotorGrab.spin(reverse, GRAB_SPEED, percent);
          MotorGrab.spin(reverse, HOLD_CHIPS, percent);
          wait(3, seconds);
          
          //reverse bot
          MotorRight.setPosition(0, turns);
          MotorLeft.spin(reverse,SPEED,percent);
          MotorRight.spin(reverse,SPEED,percent);
          while (MotorRight.position(turns) > -1)
          {}
          MotorLeft.stop(brake);
          MotorRight.stop(brake);
       
          //carry first snack in basket, second snack is still held in claw
          if (i == 0)
            dropBasket();
          if (p != 0)
          {
            robotTurn("left");
            MotorLeft.spin(forward, SPEED, percent);
            MotorRight.spin(forward, SPEED, percent);
            MotorRight.setPosition(0, turns);
            while (MotorRight.position(turns) * WHEEL_CIRC < CHIP_DISTANCE * p - CHIP_DISTANCE_CORRECTION_FACTOR * p);
            {}
            MotorLeft.stop();
            MotorRight.stop();
            robotTurn("right");
          }

          //break out of for loop
          //change to constant for legibility NOTENOTE
          p = 4;
        }
        else
        {
          //call function
          if (p < 2)
            nextChip(colour);
          else
            {
              MotorRight.setPosition(0, turns);
              MotorLeft.spin(reverse,SPEED,percent);
              MotorRight.spin(reverse,SPEED,percent);
              while (MotorRight.position(turns) > -1)
              {}
              MotorLeft.stop(brake);
              MotorRight.stop(brake);
              robotTurn("left");
              MotorLeft.spin(forward, SPEED, percent);
              MotorRight.spin(forward, SPEED, percent);
              MotorRight.setPosition(0, turns);
              while (MotorRight.position(turns) * WHEEL_CIRC < CHIP_DISTANCE * p - CHIP_DISTANCE_CORRECTION_FACTOR * p);
              {}
              MotorLeft.stop();
              MotorRight.stop();
              robotTurn("right");
            }
        }
      }  
    }
  }
  Brain.playSound(tada);
}

void nextChip(std::string colour)
{

    // reverse
    MotorLeft.spin(reverse, SPEED, percent);
    MotorRight.spin(reverse, SPEED, percent);
    MotorRight.setPosition(0, turns);
    while (MotorRight.position(turns) > -1)
    {
    }
    MotorLeft.stop();
    MotorRight.stop();

    // turn right
    robotTurn("right");
    MotorRight.setPosition(0, turns);

    MotorLeft.spin(forward, SPEED, percent);
    MotorRight.spin(forward, SPEED, percent);
    while (MotorRight.position(turns) * WHEEL_CIRC < CHIP_DISTANCE)
    {
    }
    MotorLeft.stop(brake);
    MotorRight.stop(brake);

    robotTurn("left");
}

void dropBasket()
{
    // lower elevator
    MotorVert.spin(reverse, SPEED, percent);
    while (MotorVert.position(degrees) > 0)
    {
    }
    MotorVert.stop(brake);

    // open claw
    MotorGrab.spin(forward, GRAB_SPEED, percent);
    wait(3, seconds);
    MotorGrab.stop(brake);
}

bool moveTo(double targetPos, double &robotPos, double couchPos)
{
    if (targetPos == couchPos)
    {
        // we are at the snack bar, moving positive direction until couchPos
        // turn towards the couch (180 degrees)
        robotTurn("around");
    }

    // start driving
    MotorLeft.spin(forward, SPEED, percent);
    MotorRight.spin(forward, SPEED, percent);
    bool returnedToCouch = false;

    while (std::abs((targetPos - robotPos)) > FINAL_TOLERANCE && !returnedToCouch)
    {
        updateRobotPos(robotPos);
        wait(10, msec); 
        //debugging 
        updateRobotPos(robotPos); 
        Brain.Screen.clearScreen(); 
        Brain.Screen.setCursor(1, 1);
        Brain.Screen.print("robotPos: %f", robotPos); 
        Brain.Screen.newLine(); 
        Brain.Screen.print("targetPos: %f", targetPos); 
        Brain.Screen.newLine(); 
        Brain.Screen.print("Distance: %f", Distance2.objectDistance(mm)); 
        wait(50, msec);

        if (Distance2.objectDistance(mm) < SAFE_DISTANCE)
        {
            MotorLeft.stop();
            MotorRight.stop();

            if (!obstacleAlarm(SAFE_DISTANCE)) // obstacle didn't move away
            {
                return false;
            }
        }
    }

    MotorLeft.stop(brake);
    MotorRight.stop(brake);

    //make up for the small difference
    MotorRight.setPosition(0, turns);
    
    MotorLeft.spin(forward, SPEED*0.6, percent);
    MotorRight.spin(forward, SPEED*0.6, percent);

    while (MotorRight.position(turns) < FINAL_TOLERANCE+0.1) {}

    MotorLeft.stop(brake);
    MotorRight.stop(brake);

    
    // arrived
    return true;
}

bool obstacleAlarm(const double SAFE_DISTANCE)
{
    int alarmCount = 0;
    while (alarmCount < 3)
    {
        double dist = Distance2.objectDistance(mm);
        if (dist > 0 && dist < SAFE_DISTANCE)
        {
            Brain.Screen.print("Obstacle Detected");
            Brain.Screen.newLine();
            Brain.Screen.print("%f", dist);
            Brain.Screen.print(" mm away!");

            Brain.playSound(alarm);
            alarmCount++;
            wait(5, seconds);
        }
        else
        {
            // the path is clear
            return true;
        }
    }

    // obstacle still there after three alarms
    return false;
}

void updateRobotPos(double &robotPos)
{
    double delta = MotorLeft.position(turns); // how much we moved since last update
    int angle = (int)BrainInertial.rotation(degrees);
    angle = angle % 360;
    if (angle < 0)
    {
        angle += 360;
    }

    if (angle < 20 || angle > 340) // If facing towards snacks (decreasing to zero)
        robotPos -= delta;
    else if (std::abs(angle - 180) < 40) // If facing towards couch (increasing to couchPos)
        robotPos += delta;
    MotorLeft.setPosition(0, turns);
}

void robotTurn(std::string direction)
{
    const double TURNING_SPEED = 20, ROTATION_ANGLE = 90;

    if (direction == "right")
    {
        double tempInertialRotation = BrainInertial.rotation(degrees);
        int numTurns = 1;
        BrainInertial.setRotation(0, degrees);
        while (abs(BrainInertial.rotation(degrees) - 90) > 0.05)
        {
            if (numTurns % 2 == 0)
            {
                MotorLeft.spin(forward, TURNING_SPEED / numTurns, percent);
                MotorRight.spin(reverse, TURNING_SPEED / numTurns, percent);
                while (BrainInertial.rotation(degrees) < ROTATION_ANGLE)
                {
                }
            }
            else
            {
                MotorLeft.spin(reverse, TURNING_SPEED / numTurns, percent);
                MotorRight.spin(forward, TURNING_SPEED / numTurns, percent);
                while (BrainInertial.rotation(degrees) > ROTATION_ANGLE)
                {
                }
            }
            numTurns++;
            MotorLeft.stop(brake);
            MotorRight.stop(brake);
            wait(20, msec);
        }
        BrainInertial.setRotation(tempInertialRotation + BrainInertial.rotation(degrees), degrees);
    }
    else if (direction == "left")
    {
        double tempInertialRotation = BrainInertial.rotation(degrees);
        int numTurns = 1;
        BrainInertial.setRotation(0, degrees);
        while (abs(BrainInertial.rotation(degrees) + 90) > 0.05)
        {
            if (numTurns % 2 == 0)
            {
                MotorLeft.spin(reverse, TURNING_SPEED / numTurns, percent);
                MotorRight.spin(forward, TURNING_SPEED / numTurns, percent);
                while (BrainInertial.rotation(degrees) > -ROTATION_ANGLE)
                {
                }
            }
            else
            {
                MotorLeft.spin(forward, TURNING_SPEED / numTurns, percent);
                MotorRight.spin(reverse, TURNING_SPEED / numTurns, percent);
                while (BrainInertial.rotation(degrees) < -ROTATION_ANGLE)
                {
                }
            }
            numTurns++;
            MotorLeft.stop(brake);
            MotorRight.stop(brake);
            wait(20, msec);
        }
        BrainInertial.setRotation(tempInertialRotation + BrainInertial.rotation(degrees), degrees);
    }
    else if (direction == "around")
    {
        robotTurn("right");
        robotTurn("right");
    }
    MotorLeft.stop(brake);
    MotorRight.stop(brake);
    MotorLeft.setPosition(0, turns);
}
