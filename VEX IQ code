#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START IQ MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END IQ MACROS


// Robot configuration code.
inertial BrainInertial = inertial();
motor MotorLeft = motor(PORT4, false);
motor MotorRight = motor(PORT5, true);
motor MotorGrab = motor(PORT3, false); //WHAT DOES FALSE DO? I put false bc I didn't know what to put lol
motor MotorVert = motor(PORT1);
optical Optical6 = optical(PORT6);
distance Distance2 = distance(PORT2);
touchled TouchLED12 = touchled(PORT12);


// generating and setting random seed
void initializeRandomSeed(){
  wait(100,msec);
  double xAxis = BrainInertial.acceleration(xaxis) * 1000;
  double yAxis = BrainInertial.acceleration(yaxis) * 1000;
  double zAxis = BrainInertial.acceleration(zaxis) * 1000;
  // Combine these values into a single integer
  int seed = int(
    xAxis + yAxis + zAxis
  );
  // Set the seed
  srand(seed); 
}

// Converts a color to a string
const char* convertColorToString(color col) {
  if (col == colorType::red) return "red";
  else if (col == colorType::green) return "green";
  else if (col == colorType::blue) return "blue";
  else if (col == colorType::white) return "white";
  else if (col == colorType::yellow) return "yellow";
  else if (col == colorType::orange) return "orange";
  else if (col == colorType::purple) return "purple";
  else if (col == colorType::cyan) return "cyan";
  else if (col == colorType::black) return "black";
  else if (col == colorType::transparent) return "transparent";
  else if (col == colorType::red_violet) return "red_violet";
  else if (col == colorType::violet) return "violet";
  else if (col == colorType::blue_violet) return "blue_violet";
  else if (col == colorType::blue_green) return "blue_green";
  else if (col == colorType::yellow_green) return "yellow_green";
  else if (col == colorType::yellow_orange) return "yellow_orange";
  else if (col == colorType::red_orange) return "red_orange";
  else if (col == colorType::none) return "none";
  else return "unknown";
}


// Convert colorType to string
const char* convertColorToString(colorType col) {
  if (col == colorType::red) return "red";
  else if (col == colorType::green) return "green";
  else if (col == colorType::blue) return "blue";
  else if (col == colorType::white) return "white";
  else if (col == colorType::yellow) return "yellow";
  else if (col == colorType::orange) return "orange";
  else if (col == colorType::purple) return "purple";
  else if (col == colorType::cyan) return "cyan";
  else if (col == colorType::black) return "black";
  else if (col == colorType::transparent) return "transparent";
  else if (col == colorType::red_violet) return "red_violet";
  else if (col == colorType::violet) return "violet";
  else if (col == colorType::blue_violet) return "blue_violet";
  else if (col == colorType::blue_green) return "blue_green";
  else if (col == colorType::yellow_green) return "yellow_green";
  else if (col == colorType::yellow_orange) return "yellow_orange";
  else if (col == colorType::red_orange) return "red_orange";
  else if (col == colorType::none) return "none";
  else return "unknown";
}


void vexcodeInit() {

  // Initializing random seed.
  initializeRandomSeed(); 
}

#pragma endregion VEXcode Generated Robot Configuration

//----------------------------------------------------------------------------
//                                                                            
//    Module:       main.cpp                                                  
//    Authors:       Adam, Arthur, Isabel, and Arjun                                                  
//    Created:      {date}                                                    
//    Description:  IQ project                                                
//                                                                            
//----------------------------------------------------------------------------

// Include the IQ Library
#include "iq_cpp.h"
#include <string>
#include <cmath>

// Allows for easier use of the VEX Library
using namespace vex;

void configureAllSensors(){
  BrainInertial.calibrate();
  wait(2,seconds);
  BrainInertial.setHeading(0,degrees);
  BrainInertial.setRotation(0,degrees);
  MotorLeft.setPosition(0,turns);
  MotorRight.setPosition(0,turns);
  Brain.Screen.clearScreen();
  Brain.Screen.setFont(mono15);
  Optical6.setLight(ledState::on);
}

//Function prototypes
void waitForTouch();
void findCouch(double couchPos[2], double robotPos[2], std::string& facing);
void menuSelect(std::string order[], bool& endProgram);
bool confirm(const std::string chipString);
void getSnack(std::string snack);
void moveTo(double position[2], std::string& facing);
bool avoidObstacle(std::string facing, double robotPos[2]);
void updateRobotPos(std::string& facing, double robotPos[2]);
void robotTurn(std::string direction, std::string& facing, double robotPos[2]);
void robotTurnToFace(std::string direction, std::string& facing, double robotPos[2]);

const int X = 0, Y = 1;
const double WHEEL_CIRC = 200;
const double ROBOT_LENGTH = 250; //Not actually the length of the robot, just from the centre of the first wheels to the end. And it's approximate
const int NUM_ORDERS = 2;
const int SPEED = 40; //TORQUE IS AN ISSUE FOR MOVING THE WHEELS. Might need to use gears. Will probably need it too for the elevator :,/

int main()
{
  // Initializing Robot Configuration. DO NOT REMOVE!
  vexcodeInit();
  // Begin project code
	configureAllSensors();

  double couchPos[2] = {0,0};
  double homePos[2] = {0,0};
  double robotPos[2] = {0,0}; //Note that for positions, it depends on which direction the robot is facing. Its "centre" is the centre of the front wheel axle
  std::string facing = "plusY;";
  std::string snackSelection[NUM_ORDERS] = {""};
	bool endProgram = false;

	while(!endProgram)
	{	//The robot gets placed at the snack stand. Make sure it can see the first snack option in the line.
		
		waitForTouch();
    


    endProgram = true; //Delete this once done testing

		/*findCouch(couchPos, robotPos); //(We might be able to change this to make it not have to be in a straight line, but that can come back to this later)
		waitForTouch();
		
    for (int i = 0; i < NUM_ORDERS; i++)
      snackSelection[i] = "Nothing";
		menuSelect(snackSelection, endProgram);
		
		robotTurn("around", facing, robotPos);
		moveTo(homePos, facing);
		for (int i = 0; i < NUM_ORDERS; i++)
		{
			getSnack(snackSelection[i]); //The robot will go get the snack, pick it up, and put it in a basket (Can be changed to have the for loop include the returnHome() and returnCouch() so that it doesn't need a basket)
		}
		moveTo(couchPos, facing);
		Brain.playSound(tada);*/
	}
  Brain.programStop();
}

void waitForTouch()
{
	while (!TouchLED12.pressing())
	{}
	while (TouchLED12.pressing())
	{}
}

void findCouch(double couchPos[2], double robotPos[2], std::string& facing)
{
	const int NEAR_COUCH = 240; //Distance between the distance sensor and the couch
	
  MotorLeft.spin(reverse, SPEED, percent);
  MotorRight.spin(reverse, SPEED, percent);
  MotorLeft.setPosition(0, turns);
  while (MotorLeft.position(turns) * WHEEL_CIRC > -ROBOT_LENGTH)
  {}
  MotorLeft.stop(brake);
  MotorRight.stop(brake);

  robotTurn("around", facing, robotPos);

	MotorLeft.spin(forward, SPEED, percent);
	MotorRight.spin(forward, SPEED, percent);
	while (Distance2.objectDistance(mm) > NEAR_COUCH)
	{Brain.Screen.clearScreen(); Brain.Screen.setCursor(1,1); Brain.Screen.print("%f" ,Distance2.objectDistance(mm)); Brain.Screen.newLine(); Brain.Screen.print("%d", static_cast<int>(Distance2.objectDistance(mm) > NEAR_COUCH));}
	MotorLeft.stop(brake);
	MotorRight.stop(brake);
	couchPos[X] = 0;
	couchPos[Y] = MotorLeft.position(turns);	//This is so that you're looking at it from a top down view and the snack station is vertically placed from the couch. The x coordinate should be 0 since it's just moving in a straight line.
	
  robotTurn("around", facing, robotPos);

	Brain.Screen.setCursor(1,1);
	//Brain.playSound(tada); BRING BACK LATER. Just made silent for now. Don't want to bother others while testing.
	Brain.Screen.print("Hello!\nI am here to serve you.\nPress the touchLED when you want a snack!");
}

void menuSelect(std::string order[NUM_ORDERS], bool& endProgram)
{
  const int NUM_OPTIONS = 6;
	bool doneOrdering = false;
  bool snackSelected = false;

	for (int i = 0; (i < NUM_ORDERS) && (!doneOrdering) && (!endProgram); i++)
	{
		Brain.Screen.clearScreen();
		Brain.Screen.setCursor(1,1);
		Brain.Screen.print("  What snack?");
    Brain.Screen.newLine();
    Brain.Screen.print("  Doritos");
    Brain.Screen.newLine();
    Brain.Screen.print("  Cheetos");
    Brain.Screen.newLine();
    Brain.Screen.print("  Ruffles");
    Brain.Screen.newLine();
    Brain.Screen.print("  Done");
    Brain.Screen.newLine();
    Brain.Screen.print("  End Program");
		Brain.Screen.setCursor(2,1);
		Brain.Screen.print(">");
    
    snackSelected = false;
    while(!snackSelected)
    {
      std::string buttonPressed = "";
      while (!Brain.buttonLeft.pressing() && !Brain.buttonRight.pressing() && !Brain.buttonCheck.pressing())
	  	{}
      if (Brain.buttonLeft.pressing())
        buttonPressed = "left";
      if (Brain.buttonRight.pressing())
        buttonPressed = "right";
      if (Brain.buttonCheck.pressing())
        buttonPressed = "check";
      while (Brain.buttonLeft.pressing() || Brain.buttonRight.pressing() || Brain.buttonCheck.pressing())
	  	{}
	  	if(buttonPressed == "left")
	  	{
	  		if (Brain.Screen.row() > 2)
	  		{
    			Brain.Screen.setCursor(Brain.Screen.row(), 1);
     		  Brain.Screen.print(" ");      //Overwrites the > selection arrrow
     		  Brain.Screen.setCursor(Brain.Screen.row() - 1, 1);
     		  Brain.Screen.print(">");
     		}
    	}
    	if (buttonPressed == "right")
    	{
     		if (Brain.Screen.row() < NUM_OPTIONS)
     		{
     		  Brain.Screen.setCursor(Brain.Screen.row(), 1);
     		  Brain.Screen.print(" ");      //Clears the > selection arrrow
     		  Brain.Screen.setCursor(Brain.Screen.row() + 1, 1);
     		  Brain.Screen.print(">");
     		}
    	}
      if (buttonPressed == "check")
  		{
        if (Brain.Screen.row() == 2)
          order[i] = "Doritos";
        else if (Brain.Screen.row() == 3)
          order[i] = "Cheetos";
        else if (Brain.Screen.row() == 4)
          order[i] = "Ruffles";
        else if (Brain.Screen.row() == 5)
          {
            order[i] = "Nothing";
            doneOrdering = true;
          }
        else if (Brain.Screen.row() == 6)
          endProgram = true;
        snackSelected = true;

        if (!endProgram)
        {
          if (!confirm(order[i]))
            i--;
        }
  		}
    }
	}
}

bool confirm(const std::string chipString)
{ 
	Brain.Screen.clearScreen();
	Brain.Screen.setCursor(1,1);
	Brain.Screen.print("Selected: %s", chipString.c_str());
	Brain.Screen.newLine();
	Brain.Screen.newLine();
	Brain.Screen.print("Right to confirm");
  Brain.Screen.newLine();
  Brain.Screen.print("Left to cancel"); //Might change menu
	//Lines above set the screen and then it displays a confirmation message and returns the users choice back to them so they can see their choice and decide if they want something else or if that's what they meant to select.
	while (true) //loop waits until user presses check or x
	{
		if (Brain.buttonRight.pressing()) //checks if check button is pressed
		{ 
			while(Brain.buttonRight.pressing()) //waits until the button is released
			{} 
			return true; //returns true if check is pressed
		}
		else if (Brain.buttonLeft.pressing())
		{
			while (Brain.buttonLeft.pressing())
			{}
			return false;
		}
	}
}

void getSnack(std::string snack)	//The robot will go get the snack, pick it up, and put it in a basket //GETTING REDONE AND REPLACED BY ISABEL
{
	const double CLAW_LENGTH_PLUS_5_MM = 90; //CHANGE ONCE WE MEASURE IT
	std::string searchColour = "Nothing";
	if (snack == "Fanta")
		searchColour = "orange";
	else if (snack == "Coca Cola")
		searchColour = "red";
	else if (snack == "Pepsi")
		searchColour = blue;
	else if (snack == "Sprite")
		searchColour = green;
	
	//The distance sensor and the Optical6 sensor have to be like right on top of the other for this to work, which both have to be like right on top of the claw
	MotorLeft.spin(forward,10,percent);
	MotorRight.spin(forward,10,percent);
	while (Distance2.objectDistance(mm) > CLAW_LENGTH_PLUS_5_MM)
	{}
	MotorLeft.stop(brake);
	MotorRight.stop(brake);
	
	bool snackFound = false;
	{
		if (Optical6.color() != red/*Or any of the other colours of the snacks*/){
		//Adjust the robot's position a little bit to the left/right and try again
		//If we need to, try it again with the light on
		}
		
		if (convertColorToString(Optical6.color()) == searchColour)
		{
			//Grab the snack and put in basket
			snackFound = true;
			//Move back to (0,0) (home);
		}
		else
		{
			//Move SNACK_SEPARATION_DISTANCE to the right
			//Unless it's out of options. Then return to (0,0)
		}
	}
}

//NEEDS TESTING
void moveTo(double targetPos, std::string& facing, double robotPos[2]) {  //moves along **the Y axis**
	const double APPROACH_TOLERANCE = 400; //Had to change the distances. Millimetres are surprisingly really small lol. I spent like an hour debugging something that's only issue was the distance not being big enough
	const double FINAL_TOLERANCE = 200;
	const double SAFE_DISTANCE = 120;
	
  updateRobotPos(facing, robotPos); //Made an updateRobotPos function to avoid stale data
	double currentPos = robotPos[Y]; //I gave it the Y value since it'll be moving between the couch and the $\mathrm{Snack\;Rack^{TM}}$
	double moveDistance = targetPos - currentPos;
	
  //Which direction to go?
	bool towardsCouch = (moveDistance > 0);
  if (towardsCouch)
    robotTurnToFace(minusY, facing, robotPos);
  else
    robotTurnToFace(plusY, facing, robotPos);
	
	//driving fast until APPROACH_TOLERANCE
    //drive forwards at a medium/fast speed
	MotorLeft.spin(forward, SPEED, percent); //This good, Arthur? I'm putting SPEED in the regular one, and then 0.5 * SPEED for the slow one
	MotorRight.spin(forward, SPEED, percent);
	while (std::abs(targetPos - currentPos) > APPROACH_TOLERANCE)
  {
		if (Distance2.objectDistance(mm) < SAFE_DISTANCE) //not safe! object in front
			//stop motors, run adams functions
	}
  //I moved this out of the while loop. I think it'll work like this?
	//update current position variable
    updateRobotPos(facing, robotPos);
	  double currentPos = robotPos[Y];

  MotorLeft.spin(forward, 0.5 * SPEED, percent);
	MotorRight.spin(forward, 0.5 * SPEED, percent);
	//driving slow until FINAL_TOLERANCE
	while (ABSOLUTEVALUEFUNCTION(targetPos - currentPos) > FINAL_TOLERANCE)
  {
		if (Distance2.objectDistance(mm) < SAFE_DISTANCE) //not safe! object in front
			stop motors, run adams functions  //Might have to change this a bit if it interferes with the robot stopping at the right stop at the end
	}
  updateRobotPos(facing, robotPos);
	double currentPos = robotPos[Y];
	
	//if we get to this point, it means we are within final tolerance, so we have arrive
	MotorLeft.stop(brake);
  MotorRight.stop(brake);

  //If, at the avoid function, it returns false, skip everything up until this point and call the function again to the original position
}

//NEEDS TESTING
bool avoidObstacle(std::string facing, double robotPos[2])
{
	const float STOP_DISTANCE = 200; //Change maybe
	const float AVOID_DISTANCE = 400;
	
	MotorLeft.stop(brake);
	MotorRight.stop(brake);
	
	Brain.playSound(alarm2); //HONK GET OUT THE WAY
	wait(7, seconds);
	
	if (Distance2.objectDistance(mm) > STOP_DISTANCE)
	{
		float lastEncoderVal = 0;
		bool isStuck = false;
		std::string direction = "right";
		
		for (int i = 0; i < 4; i++) //Should 4 be a const?
		{
			if (i == 0 || i == 3)
				robotTurn("right", facing, robotPos);
			else
				robotTurn("left", facing, robotPos);
			if (Distance2.objectDistance(mm) > STOP_DISTANCE)
					isStuck = true;
			if (!isStuck)
			{
				lastEncoderVal = MotorLeft.position(turns);
				MotorLeft.spin(forward, SPEED, percent);
				MotorRight.spin(forward, SPEED, percent);
				while (MotorLeft.position(turns) * WHEEL_CIRC - lastEncoderVal < AVOID_DISTANCE)
				{}
				MotorLeft.stop(brake);
				MotorRight.stop(brake);
			}
			else 
			{
        //Looks at the value of i, and undoes everything that it just did
				for (int j = i; j > 0; j--)
        {
          if (j == 0 || j == 3)
            robotTurn("left", facing, robotPos);
          else
            robotTurn("right", facing, robotPos);
          lastEncoderVal = MotorLeft.position(turns);
				  MotorLeft.spin(reverse, SPEED, percent);
				  MotorRight.spin(reverse, SPEED, percent);
				  while (MotorLeft.position(turns) * WHEEL_CIRC - lastEncoderVal > AVOID_DISTANCE)
				  {}
				  MotorLeft.stop(brake);
				  MotorRight.stop(brake);
        }
        return false; //I don't think I need to set i = 4 to break out of the loop, but in case I need to, I'm putting this here
			}
		}
	}
  return true;
}

void updateRobotPos(std::string& facing, double robotPos[2])
{
  MotorLeft.stop(brake);
	MotorRight.stop(brake);
	if (facing == "plusX" || facing == "plusY")
		robotPos[Y] = MotorLeft.position(turns);
	else if (facing == "minusX" || facing == "minusY")
		robotPos[Y] = -MotorLeft.position(turns);
    MotorLeft.setPosition(0, turns);
}

void robotTurn(std::string direction, std::string& facing, double robotPos[2]) //Turns the robot either to the left, to the right, or around 180 degrees RELATIVE TO ITSELF
{
	const double TURNING_SPEED = 20, ROTATION_ANGLE = 90;
	
	updateRobotPos(facing, robotPos);
	
	BrainInertial.setRotation(0, degrees);
	if (direction == "right")
	{
		if (facing == "plusX")
			facing = "minusY";
		else if (facing == "minusY")
			facing = "minusX";
		else if (facing == "minusX")
			facing = "plusY";
		else if (facing == "plusY")
			facing = "plusX";
		MotorLeft.spin(forward, TURNING_SPEED, percent);
		MotorRight.spin(reverse, TURNING_SPEED, percent); //Might have to change depending on how the spinning works out
		while (BrainInertial.rotation(degrees) < ROTATION_ANGLE) //Might have to change the ROTATION_ANGLE and -ROTATION_ANGLE
		{}
	}
	else if (direction == "left")
	{
		if (facing == "plusX")
			facing = "plusY";
		else if (facing == "plusY")
			facing = "minusX";
		else if (facing == "minusX")
			facing = "minusY";
		else if (facing == "minusY")
			facing = "plusX";
		MotorLeft.spin(reverse, TURNING_SPEED, percent);
		MotorRight.spin(forward, TURNING_SPEED, percent);
		while (BrainInertial.rotation(degrees) > -ROTATION_ANGLE) //Might have to change the ROTATION_ANGLE and -ROTATION_ANGLE
		{}
	}
	else if (direction == "around")
	{
		robotTurn("right", facing, robotPos);
    robotTurn("right", facing, robotPos);
	}
	MotorLeft.stop(brake);
		MotorRight.stop(brake);
	
	if (facing == "plusX")
		MotorLeft.setPosition(robotPos[X], turns);
	else if (facing == "plusY")
		MotorLeft.setPosition(robotPos[Y], turns);
	else if (facing == "minusX")
		MotorLeft.setPosition(-robotPos[X], turns);
	else if (facing == "minusY")
		MotorLeft.setPosition(-robotPos[Y], turns);
}

void robotTurnToFace(std::string direction, std::string& facing, double robotPos[2])
{
	if (direction == "plusX")
	{
		if (facing == "plusY")
			robotTurn("right", facing, robotPos);
		else if (facing == "minusX")
			robotTurn("around", facing, robotPos);
		else if (facing == "minusY")
			robotTurn("left", facing, robotPos);
	}
	else if (direction == "plusY")
	{
		if (facing == "plusX")
			robotTurn("left", facing, robotPos);
		else if (facing == "minusX")
			robotTurn("right", facing, robotPos);
		else if (facing == "minusY")
			robotTurn("around", facing, robotPos);
	}
	else if (direction == "minusX")
	{
		if (facing == "plusX")
			robotTurn("around", facing, robotPos);
		else if (facing == "plusY")
			robotTurn("left", facing, robotPos);
		else if (facing == "minusY")
			robotTurn("right", facing, robotPos);
	}
	else if (direction == "minusY")
	{
		if (facing == "plusX")
			robotTurn("right", facing, robotPos);
		else if (facing == "plusY")
			robotTurn("around", facing, robotPos);
		else if (facing == "minusX")
			robotTurn("left", facing, robotPos);
	}		
}
